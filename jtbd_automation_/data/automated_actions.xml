<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <!-- 1. AUTOMATED ACTIONS (TRIGGERS) -->

    <!-- Opportunity Won Trigger -->
    <record id="automated_action_opportunity_won" model="base.automation">
        <field name="name">Create Project When Opportunity Won</field>
        <field name="model_id" ref="model_crm_lead" />
        <field name="trigger">on_write</field>
        <field name="filter_domain">[('stage_id.name', '=', 'Won')]</field>
        <field name="filter_pre_domain">[('stage_id.name', '!=', 'Won')]</field>
        <field name="state">code</field>
        <field name="code"><![CDATA[
            action = env.ref('jtbd_automation.server_action_create_project_from_opportunity')
            action.with_context({'active_id': record.id, 'active_ids': [record.id], 'active_model':
            'crm.lead'}).run()
        ]]>
        </field>
    </record>

    <!-- Opportunity Import Trigger -->
    <record id="automated_action_opportunity_import" model="base.automation">
        <field name="name">Create Project When Opportunity Imported as Won</field>
        <field name="model_id" ref="model_crm_lead" />
        <field name="trigger">on_create</field>
        <field name="filter_domain">[('stage_id.name', '=', 'Won')]</field>
        <field name="state">code</field>
        <field name="code"><![CDATA[
            action = env.ref('jtbd_automation.server_action_create_project_from_opportunity')
            action.with_context({'active_id': record.id, 'active_ids': [record.id], 'active_model':
            'crm.lead'}).run()
        ]]>
        </field>
    </record>

    <!-- Project Created Trigger -->
    <record id="automated_action_project_created" model="base.automation">
        <field name="name">Generate Tasks When Project Created from Opportunity</field>
        <field name="model_id" ref="model_project_project" />
        <field name="trigger">on_create</field>
        <field name="filter_domain">[('x_opportunity_id', '!=', False)]</field>
        <field name="state">code</field>
        <field name="code"><![CDATA[
            if not record.is_template:
            action = env.ref('jtbd_automation.server_action_generate_tasks_from_template')
            action.with_context({'active_id': record.id, 'active_ids': [record.id], 'active_model':
            'project.project'}).run()
        ]]>
        </field>
    </record>

    <!-- Task Completion Monitoring -->
    <record id="automated_action_task_completed" model="base.automation">
        <field name="name">Update Project Progress on Task Completion</field>
        <field name="model_id" ref="model_project_task" />
        <field name="trigger">on_write</field>
        <field name="filter_domain">[('stage_id.is_closed', '=', True)]</field>
        <field name="filter_pre_domain">[('stage_id.is_closed', '=', False)]</field>
        <field name="state">code</field>
        <field name="code"><![CDATA[
            action = env.ref('jtbd_automation.server_action_update_project_progress')
            action.with_context({'active_id': record.id, 'active_ids': [record.id], 'active_model':
            'project.task'}).run()
        ]]>
        </field>
    </record>

    <!-- 2. SERVER ACTIONS (PYTHON CODE) -->

    <!-- Create Project from Opportunity -->
    <record id="server_action_create_project_from_opportunity" model="ir.actions.server">
        <field name="name">Create Project from Opportunity</field>
        <field name="model_id" ref="model_crm_lead" />
        <field name="state">code</field>
        <field name="code"><![CDATA[
            def create_project_from_opportunity(self):
            # ===== NEW ENHANCEMENT FUNCTIONS =====
            def check_existing_projects(opportunity_id):
            existing_projects = self.env['project.project'].search([
            ('x_opportunity_id', '=', opportunity_id)
            ])

            if existing_projects:
            return existing_projects[0].id
            return False

            def find_or_create_template(job_category):
            template = self.env['project.project'].search([
            ('is_template', '=', True),
            ('name', 'ilike', job_category)
            ], limit=1)

            if not template:
            # Create a basic template with default values
            template = self.env['project.project'].create({
            'name': f"{job_category} Project Template",
            'is_template': True,
            'x_job_category': job_category,
            'description': f"Automatically created template for {job_category}"
            })

            # Create basic stages
            stage_names = ['Discovery', 'Implementation', 'Training', 'Verification']
            for i, name in enumerate(stage_names):
            self.env['project.task.type'].create({
            'name': name,
            'sequence': i+1,
            'project_ids': [(4, template.id)]
            })

            return template

            def log_automation_error(action_name, record_id, error_message):
            import logging
            _logger = logging.getLogger(__name__)

            # Log the error
            _logger.error(f"Automation error in {action_name} for record {record_id}:
            {error_message}")

            # Create an activity for the system administrator
            admin_user = self.env.ref('base.user_admin')

            self.env['mail.activity'].create({
            'activity_type_id': self.env.ref('mail.mail_activity_data_todo').id,
            'summary': f"Automation Error in {action_name}",
            'note': f"An error occurred during the execution of {action_name} for record
            {record_id}.\n\nError message: {error_message}\n\nPlease investigate and resolve this
            issue.",
            'user_id': admin_user.id,
            'res_id': record_id,
            'res_model_id': self.env['ir.model']._get('crm.lead').id,
            'priority': '2', # High priority
            })

            # ===== INTEGRATION FUNCTIONS =====
            def create_project_budget(project_id):
            try:
            project = self.env['project.project'].browse(project_id)

            if not project.partner_id or not project.x_implementation_hours:
            return False

            # Calculate budget based on implementation hours
            hourly_rate = self.env.company.x_standard_hourly_rate if hasattr(self.env.company,
            'x_standard_hourly_rate') else 150
            project_budget = project.x_implementation_hours * hourly_rate

            # Only proceed if analytic accounting is installed
            if 'account.analytic.account' not in self.env:
            return False

            # Create analytic account for the project if it doesn't exist
            if not project.analytic_account_id:
            analytic_account = self.env['account.analytic.account'].create({
            'name': project.name,
            'partner_id': project.partner_id.id,
            'code': f"PROJ-{project.id}"
            })
            project.write({'analytic_account_id': analytic_account.id})

            # Only proceed if budgets are installed
            if 'account.budget.post' not in self.env or 'crossovered.budget' not in self.env:
            return False

            # Check if company has revenue accounts configured
            revenue_accounts = []
            if hasattr(self.env.company, 'x_project_revenue_account_ids'):
            revenue_accounts = self.env.company.x_project_revenue_account_ids.ids

            if not revenue_accounts and 'account.account' in self.env:
            # Try to find income accounts
            income_accounts = self.env['account.account'].search([
            ('user_type_id.name', 'ilike', 'Income')
            ], limit=1)
            if income_accounts:
            revenue_accounts = income_accounts.ids

            if not revenue_accounts:
            return False

            # Create budget entries
            budget_entry = self.env['account.budget.post'].create({
            'name': f"Budget for {project.name}",
            'account_ids': [(6, 0, revenue_accounts)]
            })

            budget = self.env['crossovered.budget'].create({
            'name': f"Budget {project.name}",
            'date_from': project.date_start,
            'date_to': project.date,
            'crossovered_budget_line': [(0, 0, {
            'analytic_account_id': project.analytic_account_id.id,
            'general_budget_id': budget_entry.id,
            'date_from': project.date_start,
            'date_to': project.date,
            'planned_amount': project_budget,
            })]
            })

            return budget.id
            except Exception as e:
            # Log but don't fail if budget creation fails
            log_automation_error('create_project_budget', project_id, str(e))
            return False

            def configure_timesheet_validation(project_id):
            try:
            project = self.env['project.project'].browse(project_id)

            # Enable timesheet tracking if timesheets are installed
            if hasattr(project, 'allow_timesheets'):
            project.write({
            'allow_timesheets': True,
            'allow_billable': True if hasattr(project, 'allow_billable') else False
            })

            # Set timesheet validation settings if validation module is installed
            if 'project.timesheet.validation' in self.env:
            self.env['project.timesheet.validation'].create({
            'project_id': project.id,
            'validation_type': 'manager',
            'manager_notification': True,
            'timesheet_reminder': True,
            'reminder_frequency': 'weekly'
            })

            # Update tasks to be timesheet-enabled
            project_tasks = self.env['project.task'].search([
            ('project_id', '=', project.id)
            ])

            for task in project_tasks:
            if hasattr(task, 'allow_timesheets'):
            task_vals = {
            'allow_timesheets': True
            }
            if hasattr(task, 'remaining_hours'):
            task_vals['remaining_hours'] = task.planned_hours

            task.write(task_vals)

            return True
            except Exception as e:
            # Log but don't fail if timesheet config fails
            log_automation_error('configure_timesheet_validation', project_id, str(e))
            return False

            def configure_client_portal(project_id):
            try:
            project = self.env['project.project'].browse(project_id)

            if not project.partner_id:
            return False

            # Enable portal access for the project if portal is installed
            if hasattr(project, 'portal_visible'):
            project.write({
            'portal_visible': True,
            'privacy_visibility': 'portal'
            })

            # Configure which tasks are visible in portal
            if 'project.task.type' in self.env:
            visible_task_stages = self.env['project.task.type'].search([
            ('project_ids', 'in', project.id),
            ('name', 'in', ['Done', 'In Progress', 'Ready', 'Implementation', 'Verification'])
            ])

            for stage in visible_task_stages:
            if hasattr(stage, 'portal_visible'):
            stage.write({'portal_visible': True})

            # Configure portal users for the client
            if project.partner_id.user_ids:
            portal_group = self.env.ref('base.group_portal', raise_if_not_found=False)
            if portal_group:
            for user in project.partner_id.user_ids:
            if not user.has_group('base.group_portal'):
            user.write({'groups_id': [(4, portal_group.id, 0)]})
            else:
            # Only create portal user if portal module is installed and client has email
            if 'portal.wizard' in self.env and project.partner_id.email:
            # Create a portal user for the client
            user_values = {
            'name': project.partner_id.name,
            'email': project.partner_id.email,
            'login': project.partner_id.email,
            'partner_id': project.partner_id.id,
            'groups_id': [(6, 0, [self.env.ref('base.group_portal', raise_if_not_found=False).id])]
            }

            # Check if user already exists
            existing_user = self.env['res.users'].search([
            ('login', '=', project.partner_id.email)
            ], limit=1)

            if not existing_user:
            try:
            new_user = self.env['res.users'].create(user_values)

            # Send portal access invitation
            wizard = self.env['portal.wizard'].create({
            'user_ids': [(0, 0, {
            'partner_id': project.partner_id.id,
            'email': project.partner_id.email,
            'in_portal': True,
            })]
            })
            wizard.action_apply()
            except Exception as e:
            log_automation_error('create_portal_user', project.id, str(e))

            return True
            except Exception as e:
            # Log but don't fail if portal config fails
            log_automation_error('configure_client_portal', project_id, str(e))
            return False

            # ===== MAIN FUNCTION (ENHANCED) =====
            for opportunity in self:
            try:
            if opportunity.stage_id.name == 'Won' and opportunity.x_job_category:
            # Check for existing projects first
            existing_project_id = check_existing_projects(opportunity.id)
            if existing_project_id:
            # Project already exists, just update opportunity
            opportunity.write({
            'project_id': existing_project_id,
            'x_outcome_status': 'Initial Setup'
            })
            continue

            # Find or create template
            template = find_or_create_template(opportunity.x_job_category)

            # Calculate project duration based on implementation hours
            imp_hours = opportunity.x_implementation_hours or 0
            duration_days = max(14, int(imp_hours / 8)) # minimum 2 weeks, otherwise 8 hours per day
            # Create project from template
            project_vals = {
            'name': f"{opportunity.x_job_category} Implementation - {opportunity.name}",
            'partner_id': opportunity.partner_id.id,
            'user_id': opportunity.user_id.id,
            'x_opportunity_id': opportunity.id,
            'x_job_category': opportunity.x_job_category,
            'x_job_statement': opportunity.x_job_statement,
            'x_outcome_target': opportunity.x_outcome_target,
            'x_outcome_metric': opportunity.x_outcome_metric,
            'x_target_value': opportunity.x_target_value,
            'x_current_value': opportunity.x_current_value,
            'x_outcome_status': 'Not Started',
            'x_risk_level': opportunity.x_risk_level,
            'x_implementation_hours': opportunity.x_implementation_hours,
            'x_support_hours': opportunity.x_support_hours,
            'x_cac': opportunity.x_cac,
            'x_gross_margin': opportunity.x_gross_margin,
            'date_start': fields.Date.today(),
            'date': fields.Date.today() + datetime.timedelta(days=duration_days)
            }

            new_project = self.env['project.project'].create(project_vals)

            # Link the project back to the opportunity
            opportunity.write({
            'project_id': new_project.id,
            'x_outcome_status': 'Initial Setup'
            })

            # ===== CALL INTEGRATION FUNCTIONS =====
            create_project_budget(new_project.id)
            configure_timesheet_validation(new_project.id)
            configure_client_portal(new_project.id)

            # Trigger the task generation server action
            new_project.generate_tasks_from_template(template.id)

            # Send notification
            self.env['mail.activity'].create({
            'activity_type_id': self.env.ref('mail.mail_activity_data_todo').id,
            'summary': f"New project created for {opportunity.name}",
            'note': f"A new project has been created based on the won opportunity for
            {opportunity.name}. Please review the project and assign tasks.",
            'user_id': opportunity.user_id.id,
            'res_id': new_project.id,
            'res_model_id': self.env['ir.model']._get('project.project').id,
            })
            except Exception as e:
            log_automation_error('create_project_from_opportunity', opportunity.id, str(e))

            return True
        ]]>
        </field>
    </record>

    <!-- Generate Tasks from Template -->
    <record id="server_action_generate_tasks_from_template" model="ir.actions.server">
        <field name="name">Generate Tasks from Template</field>
        <field name="model_id" ref="model_project_project" />
        <field name="state">code</field>
        <field name="code"><![CDATA[
            def generate_tasks_from_template(self, template_id=False):
            for project in self:
            if not template_id:
            # Find template based on job category if not provided
            template = self.env['project.project'].search([
            ('is_template', '=', True),
            ('name', 'ilike', project.x_job_category)
            ], limit=1)

            if not template:
            continue
            else:
            template = self.env['project.project'].browse(template_id)

            # Get task templates from the template project
            task_templates = self.env['project.task'].search([
            ('project_id', '=', template.id)
            ])

            # Calculate task scheduling based on project duration
            project_duration = (project.date - project.date_start).days
            tasks_count = len(task_templates)
            days_per_task = max(1, int(project_duration / tasks_count))

            # Create tasks from templates
            for i, task_template in enumerate(task_templates):
            # Calculate task deadline
            task_deadline = project.date_start + datetime.timedelta(days=(i+1) * days_per_task)

            # Replace placeholders in description
            description = task_template.description
            if description:
            description = description.replace('{{x_job_statement}}', project.x_job_statement or '')
            description = description.replace('{{x_outcome_metric}}', project.x_outcome_metric or
            '')
            description = description.replace('{{x_current_value}}', str(project.x_current_value or
            0))
            description = description.replace('{{x_target_value}}', str(project.x_target_value or
            0))
            mid_point = (project.x_current_value or 0) + ((project.x_target_value or 0) -
            (project.x_current_value or 0)) / 2
            description = description.replace('{{(x_current_value + x_target_value) / 2}}',
            str(round(mid_point, 2)))

            # Create the task
            task_vals = {
            'name': task_template.name,
            'project_id': project.id,
            'description': description,
            'date_deadline': task_deadline,
            'user_id': project.user_id.id,
            'planned_hours': task_template.planned_hours,
            'x_task_type': task_template.x_task_type,
            'x_task_phase': task_template.x_task_phase,
            'x_estimated_hours': task_template.planned_hours,
            'x_jtbd_context': task_template.x_jtbd_context,
            'x_deliverables': task_template.x_deliverables,
            'x_definition_of_done': task_template.x_definition_of_done,
            'stage_id': self.env['project.task.type'].search([
            ('name', 'ilike', 'New'),
            ('project_ids', 'in', project.id)
            ], limit=1).id
            }

            self.env['project.task'].create(task_vals)

            # Create milestone tasks
            self._create_milestone_tasks(project)

            return True

            def _create_milestone_tasks(self, project):
            # Create baseline milestone
            baseline_task = self.env['project.task'].create({
            'name': f"Baseline {project.x_outcome_metric} Measurement",
            'project_id': project.id,
            'description': f"""Document the baseline measurement for the primary outcome metric.

            JTBD Context:
            - Job Statement: {project.x_job_statement}
            - Outcome Metric: {project.x_outcome_metric}
            - Current Value: {project.x_current_value}

            Deliverables:
            1. Baseline measurement report
            2. Documentation of measurement methodology
            3. Contributing factor analysis

            Definition of Done:
            - Accurate baseline value confirmed
            - Measurement methodology documented
            - Baseline report approved by client""",
            'date_deadline': project.date_start + datetime.timedelta(days=7),
            'user_id': project.user_id.id,
            'planned_hours': 4,
            'x_task_type': 'Milestone',
            'is_milestone': True
            })

            # Create mid-point milestone
            mid_point_date = project.date_start + datetime.timedelta(days=int((project.date -
            project.date_start).days / 2))
            mid_value = (project.x_current_value or 0) + ((project.x_target_value or 0) -
            (project.x_current_value or 0)) / 2

            midpoint_task = self.env['project.task'].create({
            'name': f"Mid-point {project.x_outcome_metric} Review",
            'project_id': project.id,
            'description': f"""Conduct mid-point measurement and review of progress toward target
            outcome.

            JTBD Context:
            - Job Statement: {project.x_job_statement}
            - Outcome Metric: {project.x_outcome_metric}
            - Baseline Value: {project.x_current_value}
            - Target Value: {project.x_target_value}
            - Expected Mid-point Value: {round(mid_value, 2)}

            Deliverables:
            1. Mid-point progress report
            2. Variance analysis (actual vs. expected)
            3. Adjustment recommendations if needed

            Definition of Done:
            - Accurate mid-point measurement completed
            - Progress clearly communicated to client
            - Implementation plan adjusted if necessary""",
            'date_deadline': mid_point_date,
            'user_id': project.user_id.id,
            'planned_hours': 4,
            'x_task_type': 'Milestone',
            'is_milestone': True
            })

            # Create final milestone
            final_task = self.env['project.task'].create({
            'name': f"Final {project.x_outcome_metric} Verification",
            'project_id': project.id,
            'description': f"""Measure and document the final outcome achievement.

            JTBD Context:
            - Job Statement: {project.x_job_statement}
            - Outcome Metric: {project.x_outcome_metric}
            - Baseline Value: {project.x_current_value}
            - Target Value: {project.x_target_value}

            Deliverables:
            1. Final outcome achievement report
            2. Before and after comparison
            3. Economic impact analysis
            4. Success story documentation

            Definition of Done:
            - Final measurement completed and verified
            - Achievement relative to target documented
            - Economic impact quantified
            - Success story documented""",
            'date_deadline': project.date,
            'user_id': project.user_id.id,
            'planned_hours': 4,
            'x_task_type': 'Milestone',
            'is_milestone': True
            })

            return True
        ]]>
        </field>
    </record>

    <!-- Update Project Progress -->
    <record id="server_action_update_project_progress" model="ir.actions.server">
        <field name="name">Update Project Progress</field>
        <field name="model_id" ref="model_project_task" />
        <field name="state">code</field>
        <field name="code"><![CDATA[
            def update_project_progress(self):
            for task in self:
            project = task.project_id

            # If this is a milestone task that's completed
            if task.x_task_type == 'Milestone' and task.stage_id.is_closed:
            # If it's the final verification task
            if 'Final' in task.name and 'Verification' in task.name:
            project.write({
            'x_outcome_status': 'Complete'
            })

            # Update opportunity as well
            if project.x_opportunity_id:
            project.x_opportunity_id.write({
            'x_outcome_status': 'First Outcome'
            })

            # If it's the mid-point task
            elif 'Mid-point' in task.name and 'Review' in task.name:
            project.write({
            'x_outcome_status': 'In Progress'
            })

            # Calculate overall project progress
            all_tasks = self.env['project.task'].search([
            ('project_id', '=', project.id)
            ])

            completed_tasks = sum(1 for t in all_tasks if t.stage_id.is_closed)
            progress = (completed_tasks / len(all_tasks)) * 100 if all_tasks else 0

            # Update project metrics
            project.write({
            'progress': progress
            })

            return True
        ]]>
        </field>
    </record>

    <!-- 3. SCHEDULED ACTIONS (CRON JOBS) -->

    <!-- Daily Progress Check -->
    <record id="ir_cron_daily_progress_check" model="ir.cron">
        <field name="name">Project: Daily Progress Check</field>
        <field name="model_id" ref="model_project_project" />
        <field name="state">code</field>
        <field name="code"><![CDATA[ 
        def daily_progress_check(self): # Find all active projects
            active_projects = self.env['project.project'].search([ ('is_template', '=', False),
            ('active', '=', True), ('x_outcome_status', '!=', 'Complete') ]) for project in
            active_projects: # Check for overdue tasks overdue_tasks =
            self.env['project.task'].search([ ('project_id', '=', project.id), ('date_deadline', '<', fields.Date.today()),
            ('stage_id.is_closed', '=', False)
        ])
        
        if overdue_tasks:
            # Create activity notification for project manager
            self.env['mail.activity'].create({
                'activity_type_id': self.env.ref('mail.mail_activity_data_todo').id,
                'summary': f"Overdue Tasks in {project.name}",
                'note': f"There are {len(overdue_tasks)} overdue tasks in this project. Please review and update statuses.",
                'user_id': project.user_id.id,
                'res_id': project.id,
                'res_model_id': self.env['ir.model']._get('project.project').id,
            })
        
        # Check project overall deadline
        days_to_deadline = (project.date - fields.Date.today()).days if project.date else 30
        
        if days_to_deadline <= 7 and project.progress < 70:
            # Create risk alert
            project.write({'x_risk_level': 'High Risk'})
            
            # Notify project manager
            self.env['mail.activity'].create({
                'activity_type_id': self.env.ref('mail.mail_activity_data_todo').id,
                'summary': f"Project at Risk - {project.name}",
                'note': f"This project has {days_to_deadline} days remaining but is only {project.progress}% complete. Please review and take action.",
                'user_id': project.user_id.id,
                'res_id': project.id,
                'res_model_id': self.env['ir.model']._get('project.project').id,
                'priority': '2', # High priority
            })
            
    return True
    ]]>
        </field>
        <field name="interval_number">1</field>
        <field name="interval_type">days</field>
        <field name="numbercall">-1</field>
        <field name="doall" eval="False" />
        <field name="active" eval="True" />
    </record>

    <!-- Weekly Client Status Update -->
    <record id="ir_cron_weekly_client_status_update" model="ir.cron">
        <field name="name">Project: Weekly Client Status Update</field>
        <field name="model_id" ref="model_project_project" />
        <field name="state">code</field>
        <field name="code"><![CDATA[
        def weekly_client_status_update(self): # Find all active client projects
            active_projects = self.env['project.project'].search([ ('is_template', '=', False),
            ('active', '=', True), ('partner_id', '!=', False) ]) for project in active_projects: #
            Skip if no email or partner if not project.partner_id or not project.partner_id.email:
            continue # Get recent progress tasks_completed_this_week =
            self.env['project.task'].search_count([ ('project_id', '=', project.id),
            ('stage_id.is_closed', '=', True), ('write_date', '>=', fields.Date.today() -
            datetime.timedelta(days=7)) ]) # Only send update if there's progress to report if
            tasks_completed_this_week > 0 or project.x_outcome_status != 'Not Started': # Prepare
            task summary all_tasks = self.env['project.task'].search([('project_id', '=',
            project.id)]) completed_tasks = [t for t in all_tasks if t.stage_id.is_closed]
            upcoming_tasks = self.env['project.task'].search([ ('project_id', '=', project.id),
            ('stage_id.is_closed', '=', False), ('date_deadline', '>=', fields.Date.today()),
            ('date_deadline', '<=', fields.Date.today() + datetime.timedelta(days=14))
            ], limit=3)
            
            # Compose email body
            email_body = f"""
            <p>Hello {project.partner_id.name},</p>
            
            <p>Here's your weekly status
            update for the <strong>{project.name}</strong> project:</p>
            
            <h3>Project Progress</h3>
            <p>Overall
            completion: <strong>{round(project.progress, 1)}%</strong></p>
            <p>Current status: <strong>
            {project.x_outcome_status}</strong></p>
            <p>Tasks completed this week: <strong>
            {tasks_completed_this_week}</strong></p>
            <p>Total tasks completed: <strong>
            {len(completed_tasks)}</strong> of {len(all_tasks)}</p>
            
            <h3>Upcoming Tasks</h3>
            <ul> """
            for task in upcoming_tasks: email_body += f"<li><strong>{task.name}</strong> (Due:
            {task.date_deadline})</li>" email_body += """ </ul>
            
            <p>If you have any questions or need
            more information, please don't hesitate to reach out to your project manager.</p>
            
            <p>Thank
            you,<br /> The Client Success Team</p> """ # Send email self.env['mail.mail'].create({
            'subject': f"Weekly Update: {project.name}", 'body_html': email_body, 'email_from':
            project.user_id.email or self.env.company.email, 'email_to': project.partner_id.email,
            'author_id': project.user_id.partner_id.id, 'model': 'project.project', 'res_id':
            project.id, }).send() return True 
            ]]>
            </field>
        <field name="interval_number">1</field>
        <field name="interval_type">weeks</field>
        <field name="numbercall">-1</field>
        <field name="doall" eval="False" />
        <field name="active" eval="True" />
    </record>

    <!-- Monthly Portfolio Review -->
    <record id="ir_cron_monthly_portfolio_review" model="ir.cron">
        <field name="name">Project: Monthly Portfolio Review</field>
        <field name="model_id" ref="model_project_project" />
        <field name="state">code</field>
        <field name="code"><![CDATA[
        def monthly_portfolio_review(self): # Generate a comprehensive portfolio
            review for management # Get all active projects active_projects =
            self.env['project.project'].search([ ('is_template', '=', False), ('active', '=', True)
            ]) # Prepare statistics by job category stats_by_category = {} for project in
            active_projects: category = project.x_job_category or 'Uncategorized' if category not in
            stats_by_category: stats_by_category[category] = { 'count': 0, 'completed': 0,
            'on_track': 0, 'at_risk': 0, 'avg_progress': 0, 'total_hours': 0 }
            stats_by_category[category]['count'] += 1 stats_by_category[category]['total_hours'] +=
            project.x_implementation_hours or 0 if project.x_outcome_status == 'Complete':
            stats_by_category[category]['completed'] += 1 elif project.x_risk_level == 'High Risk':
            stats_by_category[category]['at_risk'] += 1 else:
            stats_by_category[category]['on_track'] += 1 stats_by_category[category]['avg_progress']
            += project.progress or 0 # Calculate averages for category in stats_by_category: if
            stats_by_category[category]['count'] > 0: stats_by_category[category]['avg_progress'] /=
            stats_by_category[category]['count'] # Generate report report_body = """ <h1>Monthly
            Project Portfolio Review</h1>
    <p>Date: {}</p>
    
    <h2>Portfolio Summary</h2>
    <p>Total Active
            Projects: {}</p>
    <p>Projects Completed This Month: {}</p>
    <p>Projects At Risk: {}</p>
    <p>Average
            Project Progress: {}%</p>
    
    <h2>Breakdown by Job Category</h2>
    <table border="1"
                cellpadding="5" cellspacing="0">
                <tr>
                    <th>Category</th>
                    <th>Projects</th>
                    <th>Completed</th>
                    <th>On Track</th>
                    <th>At Risk</th>
                    <th>Avg Progress</th>
                    <th>Total Hours</th>
                </tr> """.format( fields.Date.today(),
            len(active_projects), sum(1 for p in active_projects if p.x_outcome_status ==
            'Complete'), sum(1 for p in active_projects if p.x_risk_level == 'High Risk'),
            round(sum(p.progress or 0 for p in active_projects) / len(active_projects) if
            active_projects else 0, 1) ) for category, stats in stats_by_category.items():
            report_body += """ <tr>
                    <td>{}</td>
                    <td>{}</td>
                    <td>{}</td>
                    <td>{}</td>
                    <td>{}</td>
                    <td>{}%</td>
                    <td>{}</td>
                </tr> """.format( category, stats['count'],
            stats['completed'], stats['on_track'], stats['at_risk'], round(stats['avg_progress'],
            1), stats['total_hours'] ) report_body += """ </table>
    
    <h2>Projects At Risk</h2>
    <table
                border="1" cellpadding="5" cellspacing="0">
                <tr>
                    <th>Project</th>
                    <th>Client</th>
                    <th>Progress</th>
                    <th>Deadline</th>
                    <th>Project Manager</th>
                </tr> """ at_risk_projects = [p for p in
            active_projects if p.x_risk_level == 'High Risk'] for project in at_risk_projects:
            report_body += """ <tr>
                    <td>{}</td>
                    <td>{}</td>
                    <td>{}%</td>
                    <td>{}</td>
                    <td>{}</td>
                </tr> """.format( project.name,
            project.partner_id.name if project.partner_id else 'N/A', round(project.progress or 0,
            1), project.date or 'N/A', project.user_id.name if project.user_id else 'Unassigned' )
            report_body += """ </table> """ # Find management users to send the report to managers =
            self.env['res.users'].search([ ('groups_id', 'in',
            self.env.ref('project.group_project_manager').id) ]) # Send email to managers for
            manager in managers: self.env['mail.mail'].create({ 'subject': f"Monthly Project
            Portfolio Review - {fields.Date.today().strftime('%B %Y')}", 'body_html': report_body,
            'email_from': self.env.company.email, 'email_to': manager.email, 'model':
            'project.project', 'res_id': False, }).send() return True 
            ]]>
            </field>
        <field name="interval_number">1</field>
        <field name="interval_type">months</field>
        <field name="numbercall">-1</field>
        <field name="doall" eval="False" />
        <field name="active" eval="True" />
    </record>
</odoo>